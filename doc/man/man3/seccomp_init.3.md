NAME
====

seccomp\_init, seccomp\_reset - Initialize the seccomp filter state

SYNOPSIS
========

    #include <seccomp.h>

    typedef void * scmp_filter_ctx;

    scmp_filter_ctx seccomp_init(uint32_t def_action);
    int seccomp_reset(scmp_filter_ctx ctx, uint32_t def_action);

    Link with -lseccomp.

DESCRIPTION
===========

The **seccomp\_init**() and **seccomp\_reset**() functions
(re)initialize the internal seccomp filter state, prepares it for use,
and sets the default action based on the *def\_action* parameter. The
**seccomp\_init**() function must be called before any other libseccomp
functions as the rest of the library API will fail if the filter context
is not initialized properly. The **seccomp\_reset**() function releases
the existing filter context state before reinitializing it and can only
be called after a call to **seccomp\_init**() has succeeded.

When the caller is finished configuring the seccomp filter and has
loaded it into the kernel, the caller should call
**seccomp\_release**(3) to release all of the filter context state.

Valid *def\_action* values are as follows:

**SCMP\_ACT\_KILL**

:   The thread will be terminated by the kernel with SIGSYS when it
    calls a syscall that does not match any of the configured seccomp
    filter rules. The thread will not be able to catch the signal.

**SCMP\_ACT\_KILL\_PROCESS**

:   The entire process will be terminated by the kernel with SIGSYS when
    it calls a syscall that does not match any of the configured seccomp
    filter rules.

**SCMP\_ACT\_TRAP**

:   The thread will be sent a SIGSYS signal when it calls a syscall that
    does not match any of the configured seccomp filter rules. It may
    catch this and change its behavior accordingly. When using
    SA\_SIGINFO with **sigaction**(2), si\_code will be set to
    SYS\_SECCOMP, si\_syscall will be set to the syscall that failed the
    rules, and si\_arch will be set to the AUDIT\_ARCH for the active
    ABI.

**SCMP\_ACT\_ERRNO(uint16\_t errno)**

:   The thread will receive a return value of *errno* when it calls a
    syscall that does not match any of the configured seccomp filter
    rules.

**SCMP\_ACT\_TRACE(uint16\_t msg\_num)**

:   If the thread is being traced and the tracing process specified the
    **PTRACE\_O\_TRACESECCOMP** option in the call to **ptrace**(2), the
    tracing process will be notified, via **PTRACE\_EVENT\_SECCOMP**,
    and the value provided in *msg\_num* can be retrieved using the
    **PTRACE\_GETEVENTMSG** option.

**SCMP\_ACT\_LOG**

:   The seccomp filter will have no effect on the thread calling the
    syscall if it does not match any of the configured seccomp filter
    rules but the syscall will be logged.

**SCMP\_ACT\_ALLOW**

:   The seccomp filter will have no effect on the thread calling the
    syscall if it does not match any of the configured seccomp filter
    rules.

RETURN VALUE
============

The **seccomp\_init**() function returns a filter context on success,
NULL on failure. The **seccomp\_reset**() function returns zero on
success, negative errno values on failure.

EXAMPLES
========

    #include <seccomp.h>

    int main(int argc, char *argv[])
    {
    	int rc = -1;
    	scmp_filter_ctx ctx;

    	ctx = seccomp_init(SCMP_ACT_KILL);
    	if (ctx == NULL)
    		goto out;

    	/* ... */

    	rc = seccomp_reset(ctx, SCMP_ACT_KILL);
    	if (rc < 0)
    		goto out;

    	/* ... */

    out:
    	seccomp_release(ctx);
    	return -rc;
    }

NOTES
=====

While the seccomp filter can be generated independent of the kernel,
kernel support is required to load and enforce the seccomp filter
generated by libseccomp.

The libseccomp project site, with more information and the source code
repository, can be found at https://github.com/seccomp/libseccomp. This
tool, as well as the libseccomp library, is currently under development,
please report any bugs at the project site or directly to the author.

AUTHOR
======

Paul Moore \<paul\@paul-moore.com\>

SEE ALSO
========

**seccomp\_release**(3)
